from .parser_helpers import *

# Code @generated by parsergen; do not edit!
from parsergen.parser_utils import GeneratedParser, TokenStream, Node, Filler
from parsergen.parser_utils import memoize, memoize_left_rec
from functools import reduce

class CustomParser(GeneratedParser):
    @memoize
    def program(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._loop_0()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            p = parts[0]
            return p
        self.goto(pos)
        
        return None
        
    def _loop_0(self):
        children = []
        while True:
            pos = self.mark()
            part = self.instruction()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    @memoize
    def instruction(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('COLON')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            i = parts[0]
            return "jmp_point", i.value
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.expect('INSTRUCTION')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.params()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            opcode = parts[0]
            params = parts[1]
            return (opcode.value, params)
        self.goto(pos)
        
        return None
        
    @memoize
    def params(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.factor()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_1()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            first = parts[0]
            rest = parts[1]
            return process_params(first, rest)
        self.goto(pos)
        
        return None
        
    def _loop_1(self):
        children = []
        while True:
            pos = self.mark()
            part = self._expr_list_2()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _expr_list_2(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('COMMA')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.factor()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    @memoize_left_rec
    def factor(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('LPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.factor()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            i = parts[1]
            return ("addr", i)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            i = parts[0]
            return ("reg" if i.value.lower() in REGISTERS else "jmp_pointer", i.value)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.num()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            i = parts[0]
            return i
        self.goto(pos)
        
        return None
        
    @memoize
    def num(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._or_3()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            i = parts[0]
            return ("cv", i.value)
        self.goto(pos)
        
        return None
        
    def _or_3(self):
        pos = self.mark()
        part = self.expect('INT')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('HEX')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('BIN')
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
